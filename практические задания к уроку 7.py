# Задание 7.1
print("Задание 7.1")
#Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора класса (метод init()),
# который должен принимать данные (список списков) для формирования матрицы.
# Подсказка: матрица — система некоторых математических величин, расположенных в виде прямоугольной схемы.
# Следующий шаг — реализовать перегрузку метода str() для вывода матрицы в привычном виде.
# Далее реализовать перегрузку метода add() для реализации операции сложения двух объектов класса Matrix (двух матриц).
# Результатом сложения должна быть новая матрица.
# Подсказка: сложение элементов матриц выполнять поэлементно —
# первый элемент первой строки первой матрицы складываем с первым элементом первой строки второй матрицы и т.д.

class Matrix:
    def __init__(self, list1):
        self.list1 = list1

    def __str__(self):
       return str('\n'.join(['\t'.join([str(el) for el in i]) for i in self.list1]))

    def __add__(self, list_new):
        for i in range(len(self.list1)):
            for j in range(len(list_new.list1[i])):
                self.list1[i][j] = self.list1[i][j] + list_new.list1[i][j]
        return Matrix.__str__(self)


m = Matrix([[-15, 20, 31], [-16, 30, 41], [51, 40, -17]])
new_m = Matrix([[-20, 10, 20], [-20, 10, 20], [-14, 10, 54]])
print(m.__add__(new_m))


# Задание 7.2
print("Задание 7.2")
#Реализовать проект расчета суммарного расхода ткани на производство одежды.
# Основная сущность (класс) этого проекта — одежда, которая может иметь определенное название.
# К типам одежды в этом проекте относятся пальто и костюм.
# У этих типов одежды существуют параметры: размер (для пальто) и рост (для костюма).
# Это могут быть обычные числа: V и H, соответственно.
# Для определения расхода ткани по каждому типу одежды использовать формулы:
# для пальто (V/6.5 + 0.5), для костюма (2*H + 0.3).
# Проверить работу этих методов на реальных данных. Реализовать общий подсчет расхода ткани.
# Проверить на практике полученные на этом уроке знания: реализовать абстрактные классы для основных классов проекта,
# проверить на практике работу декоратора @property.

class Clothes:
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def get_square_c(self):
        return self.width / 6.5 + 0.5

    def get_square_k(self):
        return self.height * 2 + 0.3

    @property
    def get_sq_full(self):
        return str(f'Общий расход ткани {(self.width / 6.5 + 0.5) + (self.height * 2 + 0.3):.2f}')


class Coat(Clothes):
    def __init__(self, width, height):
        super().__init__(width, height)
        self.square_c = (self.width / 6.5 + 0.5)

    def __str__(self):
        return f'Расход ткани на пальто {self.square_c:.2f}'


class Costume (Clothes):
    def __init__(self, width, height):
        super().__init__(width, height)
        self.square_k = (self.height * 2 + 0.3)

    def __str__(self):
        return f'Расход ткани на костюм {self.square_k:.2f}'

coat = Coat(48, 173)
costume = Costume(48, 173)
print(coat)
print(costume)
print(coat.get_sq_full)

# Задание 7.3
print("Задание 7.3")
#Реализовать программу работы с органическими клетками, состоящими из ячеек. Необходимо создать класс Клетка.
#В его конструкторе инициализировать параметр, соответствующий количеству ячеек клетки (целое число).
#В классе должны быть реализованы методы перегрузки арифметических операторов:
# сложение (__add__()), вычитание (__sub__()), умножение (__mul__()), деление (__truediv__()).
# Данные методы должны применяться только к клеткам и выполнять увеличение, уменьшение, умножение и
# целочисленное (с округлением до целого) деление клеток, соответственно.

#Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток.
# ычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность количества ячеек двух клеток> нуля,
# иначе выводить соответствующее сообщение.
# Умножение. Создается общая клетка из двух. Число ячеек общей клетки определяется как произведение кол-ва ячеек этих двух клеток.
# Деление. Создается общая клетка из двух. Число ячеек общей клетки определяется как целочисленное деление количества ячеек этих двух клеток.
# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество ячеек в ряду.
# Данный метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному аргументу.
# Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5.
# Тогда метод make_order() вернет строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5.
# Тогда метод make_order() вернет строку: *****\n*****\n*****.

class Cell:
    def __init__(self, quantity):
        self.quantity = int(quantity)

    def __add__(self, other):
        return f'Сложение. Размер клетки равен: {self.quantity + other.quantity}'

    def __sub__(self, other):
        sub = self.quantity - other.quantity
        return f'Вычитание. Размер клетки равен: {sub}' if sub > 0 else 'Вычитание. Результат - отрицательное число'

    def __mul__(self, other):
        return f'Умножение. Размер клетки равен: {self.quantity * other.quantity}'

    def __truediv__(self, other):
        return f'Деление. Размер клетки равен: {self.quantity // other.quantity}'


    def make_order(self, cells_in_row):
        row = ''
        for i in range(int(self.quantity / cells_in_row)):
            row += f'{"*" * cells_in_row}\\n '
        row += f'{"*" * (self.quantity % cells_in_row)}'
        return row


cells1 = Cell(12)
cells2 = Cell(34)
print(cells1)
print(cells1 + cells2)
print(cells2 - cells1)
print(cells2 * cells1)
print(cells2 / cells1)
print(cells1.make_order(4))
print(cells2.make_order(8))
